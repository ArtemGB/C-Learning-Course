


# План изучения теории.

## Меню
1. [Главная](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/README.md)
2. [Теория](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md).
3. [Практика](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Практика.md).
4. [Дополнительно](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Дополнительно.md).

## Содержание
1. [Введение](#Введение)
2. [Ресурсы](#Ресурсы)
3. [Дополнительные ресурсы](#дополнительные-ресурсы)
4. [Порядок изучения](#порядок-изучения)
5. [Низшие основы](#низшие-основы)
6. [Базовые понятия о C#](#1-базовые-понятия-о-c)
7. [Основные конструкции программирования на C#](#2-основные-конструкции-программирования-на-c)
8. [Наименования переменных и объектов](#3-наименования-переменных-и-объектов)
9. [Комментарии](#4-комментарии)
10. [Задание 1.1](#5-задание-11)
11. [Отладчик, мать его](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#6-отладчик-мать-его)
12. [Задание 1.2](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#7-задание-12)
13. [Святое ООП](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#святое-ооп)
14. [Основы ООП](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#1-основы-ооп) 
    1. [Инкапсуляция](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#11-инкапсуляция)
    2. [Полиморфизм объектов](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#12-полиморфизм-объектов)
15. [Задание 2.1](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#2-задание-21)
16. [Исключения](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#3-исключения)
17. [Задание 2.2](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#4-задание-22)
18. [Задание 2.3](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#5-задание-23)
19. [Интерфейсы](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#6-интерфейсы)
20. [Коллекции данных](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#7-коллекции-данных) 
    1. [Коллекции как свойства](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#71-коллекции-как-свойства)
22. [Задание 2.4](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#8-задание-24)
23. [Задание 2.5](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#9-задание-25)
24. [Задание 2.6](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#10-задание-26)
25. [Делегаты и события](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Теория.md#11-делегаты-и-события)

___

## Введение

Тут я расскажу, в каком порядке какие материалы читать и какие задания делать. Поначалу будет больше теории, потом подъедет практика. Ещё скажу пару слов по поводу ресурсов. Троелсен – это очень классный автор, которые сложные вещи объясняет просто и при этом даёт хорошую теорию. Поэтому я чаще всего буду ссылаться на него. Метанит же – это хорошая методичка, но не учебник, на него я буду ссылаться в заданиях, указывая, какие именно пункты могут быть полезны при выполнении конкретного упражнения. Третьим пунктом идёт отличная книга по паттернам проектирования, её в начале обучения мы трогать не будем. Будем изучать потом отдельно, когда освоимся с ООП и будем уверенно программировать относительно несложные программы. Эти три источника для начала являются более чем достаточными, но всегда по-прежнему есть гугл, документация майкрософта и я.))) Ещё я в каждом пункте буду кратко описывать для чего нужно знать и понимать то, что я прошу в нём прочитать, ибо зачастую при обучении я сталкивался с тем, что меня чему-то учили, давали тонну информации, но даже в паре слов не говорили, зачем это нужно, как по мне это сильно осложняет понимание материала.

[:arrow_up:Содержание](#Содержание)
____

## Ресурсы:
  1. "Язык программирования C# 7 и платформы .NET и .NET Core, 8-е изд. Эндрю Троелсен, Филипп Джепикс", можно купить, либо стырить у меня.
  2. [Метанит](https://metanit.com/sharp/tutorial/)
  3. [Паттерны](https://refactoring.guru/ru/design-patterns/csharp).

[:arrow_up:Содержание](#Содержание)

## Дополнительные ресурсы:
  1. Отличный канал [Simple Code](https://www.youtube.com/channel/UCtLKO1Cb2GVNrbU7Fi0pM0w), у мужика есть огромный курс по плюсам и совсем небольшой(на данный момент) курс по шарпам, объясняет шикарно.
  2. [ExtremeCode](https://www.youtube.com/channel/UCBNlINWfd08qgDkUTaUY4_w) - также очень хороший канал не только по шарпам, но и вообще по программированию. Парни объясняют очень круто, с мемесами, хотя их подачу могут принять не все, что печально, т.к. в юмор надо уметь(хоть и юмор у них своеобразный). Плюс эти ребятки рассказывают тот материал, который рассказывает очень мало кто, но который при этом весьма важен и интересен. 
  3. [Библиотека шарписта](https://t.me/csharpproglib) - телеграм канал, в котором кидают много хорошей литературы, статей, лекций и вакансий по шарпам.
  
 [:arrow_up:Содержание](#Содержание)
____

## Порядок изучения

- ### Низшие основы

#### 1. Базовые понятия о C#
Троелсен, читаем вот это:
- **Часть I. Введение в C# и платформу .NET** с.47
- Глава 1. Философия .NET                     с. 48
- Глава 2. Создание приложений на языке C#    с. 81

Это необходимо для общего понимания работы шарпов и платформы .NET. Данный пункт очень важен, т.к. в дальнейшем различные моменты работы с шарпами так или иначе будут требовать понимания работы дотнета. Поэтому читаем. Тут всё достаточно просто расписано, так что трудностей быть не должно.

[:arrow_up:Содержание](#Содержание)

#### 2. Основные конструкции программирования на C#
Всё тот же Троелсен:
- **Часть II. Основы программирования на C#** с.97
- Глава 3. Главные конструкции программирования на C#: часть I с.98
- Глава 3. Главные конструкции программирования на C#: часть II с.150

Здесь даётся описание базовых элементов: циклы, условные операторы, методы, условия и т.д. В принципе, читать не обязательно, но, если есть силы и время, то можно прочитать, если не уверен/а в знаниях. В целом, тут всего 53 страницы, так что можно прочитать. Во всяком случае мне спустя год программирования на шарпах оказалось полезным, т.к. некоторые вещи знал, но не осознавал. Короче - прочитал, понял, осознал. Хорошо, полезно, так что читай.

[:arrow_up:Содержание](#Содержание)

#### 3. Наименования переменных и объектов
Прежде, чем ты приступишь к первым заданиям, я скажу пару слов от себя. Наименования переменных, классов и т.д. в программировании очень важная и временами больная тема. Мы же хотим стать хорошими прогерами? Да. Для этого надо стараться писать не только работающий, но и читаемый код, чтобы твои друзья, коллеги, бухой ты с первого взгляда сразу же могли понять, что и как делает твой код. Вполне обычная ситуация, когда спустя год не можешь понять код, который сам же и сделал не смотря на то, что был трезвый и когда писал его, и когда смотрел спустя год. Одним из пунктов хорошего кода является правильное наименование всего и вся(боже, сколько же я повторяюсь, но пускай, мб так лучше в голову вобъётся). Одна из причин, по которым мне нравятся шарпы - это то, что в них всё структурировано и стандартизировано, в том числе и многие моменты в наименовании тоже. Все они описаны в моём любимом Троелсене. Но я ещё расскажу кое-что сам.

Итак - несколько правил:
- Всегда давай переменным, методам и классам имена, который позволят однозначно понять их назначение. В качестве примера приведу один метод из пространства имён String:
```csharp
using System;

public class Example
{
   public static void Main()
   {
    string StrForCheck = "Some string";
    Console.WriteLine(String.IsNullOrWhiteSpace(StrForCheck));  
   }
}
```
Итак, видим метод IsNullOrWhiteSpace, вот даже не читая документацию, можно сразу же понять, что он делает. Тут только одно но - надо хотя бы на базовом уровне знать английский. Без этого никуда. Но по названию, понятно, что делает метод. Более того, посмотри, как я назвал строку для проверки, я её так и назвал "строка для проверки", только на английском. Да, может показаться, что название длинное, но мы уже живём в то время, когда IDE позволяет дописать имя по первым нескольким символам, поэтому нет траты времени на написание такого длинного названия и риска опечатки как это было когда-то давно. Зато код понятен. Ещё - как видно - переменная (её имя) состоит из нескольких слов, каждое из которых начинается с большой буквы. Так и надо делать. Майкрософт всюду и везде делают так же потому что это правильно. Ещё посмотри на то, что String я написал как Str. Я так сделал потому что это устоявшееся сокращение этого слова и str всегда и всеми читается как string, тут неоднозначности нет. Научи себя сразу писать все названия вот так, как я тут рассказал и показал. Это очень сильно облегчает чтение кода как для тебя, так и для твоего кота... и коллег тоже, да.

 - Вот так делать нельзя
```csharp
using System;

public class Example
{
   public static void Main()
   {
    string a = "Some string";
    Console.WriteLine(String.IsNullOrWhiteSpace(a));  
   }
}
```
Что за а, зачем она и т.д. хрен поймёшь. Не называй так.

- Ещё есть моменты с такими вещами как интерфейсы, исключения, обработчики событий и т.д., у них тоже есть свои правила наименования и Тот крутой мужик, чьё имя я написал уже кучу раз всё рассказывает про эти правила в соответствующих им главах.

[:arrow_up:Содержание](#Содержание)

#### 4. Комментарии
Помимо правильного и понятного наименования объектов важной вещью являются комментарии. Возьми себе за правило комментировать код и делать это красиво. В разных компаниях существуют различные стили написания кода и требования к комментариям. Поэтому прям жётско что-то советовать я не буду, а просто скажу, как удобно делать мне. Итак:

- Можно оставить комментарий перед каким-то кодом, например так:

```csharp
private void MsgReceiver(Message msg)
{
    string mess = msg.Text.ToLower(); //Переводим всё в нижний регистр.
    mess = mess.Replace(".", "").Replace(",", "").Replace(")", "").Replace("(", "").Replace("?", ""); //Убираем лишние символы.
    //Отменяем выполнение операции, если в процессе её выполнения пользователь написал слово "отмена".
    if (mess == "отмена" && Tasker.allUsers.Users[msg.FromId.Value].IsTaskChangingInProgress == true)
    {
        Tasker.allUsers.Users[msg.FromId.Value].IsTaskChangingInProgress = false;
        //Удаляем последнюю запись, если уже был добавлен текст, иначе просто выходим из операции.
        if (Tasker.TaskProcces == Tasker.AddTaskDate)
            Tasker.allUsers.Users[msg.FromId.Value].Tasks.RemoveAt(Tasker.allUsers.Users[msg.FromId.Value].Tasks.Count - 1);
        Tasker.SaveAll();
        VKSendMsg(msg.PeerId.Value, MsgTexts.Cancel);
        return;
    }
    //Если выполняется какая-либо операция, то продолжаем её выполнять.
    if (Tasker.allUsers.Users[msg.FromId.Value].IsTaskChangingInProgress == true)
    {
        Tasker.TaskProcces(msg);
        return;
    }
    ...
```
Это кусок моего кода для вк бота, здесь я делаю два вида комментариев: после строки(на той же строке) с кодом и перед ней. Оба варианта допустимы, но я бы советовал делать вторым способом. Чем первый способ хуже, видно даже тут - комментарий не помещается в экран, строка выходит слишком длинной. Так что комментируй перед кодом.

Ещё в шарпах есть прикольная и очень полезная штука, которая позволяет комментировать любой метод, объект, переменную и т.д. особым образом. 
Вот так для поля данных класса:

```csharp
/// <summary>
/// Конфигурация приложения
/// </summary>
private readonly IConfiguration configuration;
```
И вот так для метода:

```csharp
/// <summary>
/// Сохраняет текст напоминания и просит пользователя ввести время.
/// </summary>
public static void AddTaskText(Message msg)
{
    allUsers.Users[msg.FromId.Value].Tasks.Add(new UserTask(msg.Text, new DateTime().AddYears(5000)));
    SaveAll();
    VKSendMsg(msg.PeerId.Value, MsgTexts.TaskDateAddingInstruction);
    TaskProcces = AddTaskDate;
}
```
Что нам это даёт и для чего это нужно? А при таком комментировании мы сможем посмотреть описание метода или переменной из любого места кода, просто наведя на него мышкой. Далее я бы написал "вот так:" и приложил бы скрин, но у меня сейчас под рукой нет вижуалки, так что сорян... А. Ещё, выглядит громоздко и, может быть, кажется, что писать такой коммент долго, но об этом за нас побеспокоились, поэтому нам достаточно просто написать три слеша подряд, как тут же появится шаблон коммента и нам останется только вписать свои объяснения. Ещё там будет строчка, где можно вписать описание параметров, там уже как хотите, пишите, не пишите. В большинстве случаев суть параметров ясна по их названиям (и по названиям методов). Так что приучи себя комментировать код. Супер сочинения как в школе писать не надо, но кратко и понятно обязательно. А ещё будет очень круто, если ты(или твой друг/коллега/кот) ещё и документацию напишут, тогда вообще круто будет. Сразу +50 к карме.

[:arrow_up:Содержание](#Содержание)

#### 5. Задание 1.1
Т.к. шарпы ООП язык, то давать не ООП задания тут не очень хочется, но можно. (а не хочется, потому что сразу хочу ООПэшкой закидать.) Но всё же.) Тут делаем [задание 1.1](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F.md#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-11). После него можно отдохнуть, дабы мозгу надо отдыхать и давать переварить всё информацию.

[:arrow_up:Содержание](#Содержание)

#### 6. Отладчик, мать его.
После выполнения первого задания могла возникнуть трудность с тем, что хочется понять в какие моменты программы что происходит, мб ты делал для этого промежуточные выводы или ещё что придумал. Не важно. Важно то, что для этого есть один афигенный инструмент, который ты обязан постичь принять, чтобы он стал продолжением твоего тела подобно тому, как мечу самурая. Итого, что это за штука такая и как ей пользоваться? А вот [так](https://docs.microsoft.com/ru-ru/visualstudio/debugger/what-is-debugging?view=vs-2019), ещё [так](https://docs.microsoft.com/ru-ru/visualstudio/debugger/debugger-feature-tour?view=vs-2019) и ещё вот [так](https://docs.microsoft.com/ru-ru/visualstudio/debugger/using-breakpoints?view=vs-2019). Прочитай и изучи. И приучи себя пользоваться им. Он ещё не раз спасёт тебе жизнь и тонну времени в будущем.

[:arrow_up:Содержание](#Содержание)

#### 7. Задание 1.2
Тут делаем [задание 1.2](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F.md#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-12). Там всё просто.

[:arrow_up:Содержание](#Содержание)

#### 8. Тут низшие основы всё.

[:arrow_up:Содержание](#Содержание)

____

- ### Святое ООП

**ООП** – это очень важная и крутая штука в программировании, что именно это такое и как оно работает написал прекрасный Троелсен, поэтому я тут о нём рассказывать не буду. Скажу лишь то, что данный материал нужно узнать, понять и принять. Ну и плюс ко всему это всё очень интересно.)

#### 1. Основы ООП
Троелсен, читаем вот это:
- **Часть III. Объектно-ориентированное программирование на C#** с.193
- Глава 5. Инкапсуляция с.194
- Глава 6. Наследование и полиморфизм с.242


Это прям база всего программирования (ну не прям всего, есть ещё парадигмы). Все принципы ООП надо знать и понимать. Ещё крайне советую после прочтения этих глав посмотреть [вот это видео](https://www.youtube.com/watch?v=BHNt1fcg8iw), в нём кому-то может не понравиться подача, но меня это волнует чуть меньше, чем никак, говорят в нём по делу, значит смотрим.


##### 1.1 Инкапсуляция
После прочтения этих глав вы узнали об основных составляющих ООП: инкапсуляция, наследование и полиморфизм. Хочу сделать небольшую ремарку про инкапсуляцию. В интернете, литературе и различных других источниках приводится тонна разных определений и все они кто во что горазд. Очень часто пишут, что **инкапсуляция** - "ито сокритие дянных, мол вот написяли ми *public* и *private* и всё, мы вЯЛИКИЕ ИНКАПСУЛЯТОРЫ". Нет. Нет. И ещё раз нет. Это всего лишь одно из следствий инкапсуляции. Давайте разберёмся в том, что это такое. Тут как всегда всё понятно из самого термина (почему так мало людей могут в анализ слов?), вот возьмём само слово инкапсуляция и разберём его на части, получим ин-капсуляция. Что такое капсула - это некая цельная оболочка с каким-то содержимым внутри. Опаааа, это же так похоже на класс, точнее объект класса - у нас есть сущность с данными и методами внутри, супер. Но в слове же ещё есть приставка *ин*, вспоминаем английский, там есть слово *in*, которое переводится как предлог *в*, круто. В итоге получаем *"в капсулу"*. Что же это означает? Да это означает, что мы берём все наши методы и данные и инкапсулируем их в одну сущность. Вот так:

<img src="https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Images/Incapsulation.jpg" width="576" height="324">

Теперь у нас всё вместе. Вспомним функциональное программирование, там все функции живут отдельно, глобальные переменные тоже. В ООП же всё в рамках объектов. ООП работает по принципу чёрного ящика, т.е. у нас есть объект, который умеет что-то делать, как именно он это делает нас не волнует, главное, что делает. Например, у нас есть класс Random, он генерирует случайные числа, как именно, я хз, знаю только, что, вроде, по равномерному закону их фигачит. Мы объекту этого класса на вход даём диапазон, он нам в ответ число. Всё. Внутрь мы не лезем. Оно там всё само. Точно так же мы будем делать и свои объекты. Итог - **инкапсуляция** - это объединение данных и методов в рамках одной сущности. Помимо этого, она предоставляет механизм предоставления или запрета доступа к полям или данным извне.

Отсюда вытекает ещё одна вещь, которую важно понимать - каждый объект (и метод тоже) должен выполнять свою конкретную работу. Не надо делать один огромный класс, который тащит на себе сразу все функционалы программы. Лучше делать несколько, каждый из которых будет делать свою конкретную задачу. Почему? Потому что: 
1. Структура. Так тебе самому будет проще понять, что и где у тебя, в файлах проекта будет чёткая иерархия, будет сразу понятно, кто что делает.
2. Меньше риск всё сломать. Действительно, если у тебя всё в одном классе, то гораздо легче, делая что-то одно, сломать всё остальное. В разных же классах, ты, делая одно, не трогаешь другое.
3. Модульность. При таком подходе намного проще добавлять и удалять функционал. Да, при больших сложных программах уже не отделаться простым удалением или добавлением, но будет намного проще отследить все связи между объектами, чем все связи внутри огромного объекта.

Сразу приучай себя к такому подходу. Однако знать меру тоже надо, с опытом тебе придёт понимание того, что нужно делить, а что нет. Подходи к разработке с умом и знай меру.)

##### 1.2 Полиморфизм объектов
Хочу ещё кое-что рассказать про полиморфизм объектов и то, как у себя в голове представляю это я, и как вообще объект одного класса может быть объектом другого. На самом деле, объяснение достаточно простое и наглядное (надеюсь).
Итак, для начала стоит понимать, что представить объект одного класса в виде объекта другого можно только в том случае, если эти классы являются родственниками. Причём работает этот механизм только в одну сторону от младшего класса к старшему (т.е. объект младшего класса можно привести к типу старшего).
Для наглядности я всё нарисую - вот класс человека, у которого есть данные и методы. 

<img src="https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Images/Полиморфизм%20Человек.jpg" width="800" height="600">

Далее унаследуем от него класс сотрудника с дополнительными данными и методами. 

<img src="https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Images/Полиморфизм%20Сотрудник.jpg" width="800" height="600">

Тут видно, что сотрудник является человеком с должностью и возможностью работать. И везде, где надо, мы можем использовать эти возможности. Однако бывают ситуации, где нам нужно забыть о том, что сотрудник является сотрудником, а думать о нём только как о человеке, тогда мы можем его привести к типу человека. В таком случае мы делаем вот так:

<img src="https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Images/Полиморфизм%20Сотрудник%20закрыт%20рукой.jpg" width="800" height="600">

Видно, что если закрыть ту часть, которая появилась в сотруднике, то получится самый обычный человек. В коде это выглядело бы следующим образом, только сразу скажу, что метод Talk я сделал виртуальным и переопределил в сотруднике, для чего, покажу далее.
```csharp
enum Post
{
  JediMaster,
  NotAJedi
}

class Man
{
  public string Name { get; set; }
  public string SecName { get; set; }

  public Man(string name, string secname)
  {
      Name = name;
      SecName = secname;
  }

  public virtual void Talk()
  {
      Console.WriteLine($"My name is {Name} and i'm a man.");
  }

  public void Go()
  { }
}
class Employee : Man
{
  public Post Post { get; set; }

  public Employee(string name, string secname, Post post) : base(name, secname)
  {
      Post = post;
  }

  public override void Talk()
  {
      Console.WriteLine("Hello there.");
  }

  public void DoWork()
  { }
}
static void Main(string[] args)
{
  // Создаём Оби-Вана как сотрудника.
  Employee ObiEmployee = new Employee("Obi-Wan", "Kenobi", Post.JediMaster);
  // Создаём объект человека и присваиваем ему значение Оби-Вана сотрудника.
  Man ObiMan = ObiEmployee;
  // А это класс человека, который просто человек.
  Man ArteMan = new Man("Artem", "GG");
  // А ещё мы можем сделать даже вот так.
  Man EmpMan = new Employee("EmpMan", "Да, такое возможно", Post.NotAJedi);

  // Вызываем методы, видим, что у человека доступны только Go, а у сотрудника
  // и Go, и DoWork.
  ObiMan.Go();
  ObiEmployee.DoWork();
  ObiEmployee.Go();

  /* 
   * Вызов метода, который принимает человека в качестве аругмента
   * В данном случае у нас произойдёт автоматическое приведение ObiEmployee
   * К типу Man
   */
  Console.WriteLine("Здесь вызываем Talker(ArteMan):");
  Talker(ArteMan);
  Console.WriteLine("А здесь Talker(ObiEmployee), Talker(ObiMan) и Talker(EmpMan):");
  Talker(ObiEmployee);
  Talker(ObiMan);
  Talker(EmpMan);
}

static void Talker(Man man) => man.Talk();
```

Смысл всего этого в том, что нам не нужно создавать разные методы для работы с конкретным классом, мы можем создать один и посылать в него объект любого класса наследника того, который указан в параметрах метода. И обрати внимание, что хоть мы и создали две переменные разных классов, но ссылаются они на один и тот же объект в памяти, просто мы смотрим на него с разных сторон. И в подтверждение тому вывод программы:
```
Здесь вызываем Talker(ArteMan):
My name is Artem and i'm a man.
А здесь Talker(ObiEmployee), Talker(ObiMan) и Talker(EmpMan):
Hello there.
Hello there.
Hello there.
```

Оба раза у Оби-Вана отработал метод сотрудника. У EmpMan'a тоже, хоть переменная и была типа Man, но был вызван конструктор сотрудника и вернул он нам объект соответствующего типа. Как я сказал выше, метод Talk я сделал виртуальным и переопределил его в классе сотрудника. Т.е. у нас есть две разные реализации этого метода в разных классах. Возможно, может показаться, что при приведении ObiEmloyee к типу Man должна отрабатывать та версия этого метода, которая у класса Man, но нет. Сейчас покажу почему. Вернёмся к нашей схеме и отобразим на ней то, как выглядит переопределение виртуальных методов.

<img src="https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Images/Полиморфизм%20виртуальный%20метод.jpg" width="800" height="600">

Переопределённый метод ложится новым слоем на тот, что был до него, но именно ложится поверх, потому что его всё ещё можно вызвать внутри класса через оператор base. Физически реализовано это, конечно, несколько иначе, но в голове можно держать и такую схему. Для понимания она вполне годится.

[:arrow_up:Содержание](#Содержание)

#### 2. Задание 2.1
Собственно, тут [задание 2.1](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F.md#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-21), вся инфа по нему там. Так что читай.)

[:arrow_up:Содержание](#Содержание)

#### 3. Исключения
Троелсен:
- Глава 7. Структурированная обработка исключений с.280

**Обработка исключений** - это мощнейший механизм отлавливания различных ошибок в программе. Его нужно уметь использовать и понимать, как он работает. Без этой штуки никуда. Что и как именно работает описано в главе.

[:arrow_up:Содержание](#Содержание)

#### 4. Задание 2.2
[Задание 2.2](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F.md#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-22) 
Тут всё просто, на 5 минут работы. Оно чисто для ознакомления, полноценно с исключениями мы поработаем в заданиях, продолжающих то, что мы начали в 2.1

[:arrow_up:Содержание](#Содержание)

#### 5. Задание 2.3
[Задание 2.3](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F.md#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-23)

[:arrow_up:Содержание](#Содержание)

#### 6. Интерфейсы
Троелсен:
- Глава 8. Работа с интерфейсами с.306

Интерфейсы крайне важная и крутая штука в программировании. Они позволяют реализовать огромное количество паттернов проектирования, с их помощью можно делать очень много классных вещей. При прочтении главы может быть не совсем понятно, как они работают и для чего нужно, но со временем тебе придёт понимание, что они крутые ребята и ты начнёшь программировать на них, используя всех их преимущества. Интерфейсы очень удобны там, где у нас есть множество различных классов, у которых где-то пересекается поведение. Если все эти классы будут реализовать интерфейс, в котором объявлено это общее поведение, то мы, например, сможем работать с ними в каком-то методе, который принимает объекты этого интерфейса, и нам будет пофиг, что классы во всём остальном разные, что они даже не связаны родством друг с другом никак кроме как через интерфейс. У них общее поведение, и метод будет его использовать. 

Задания на интерфейсы будут далее. Вообще, мы, конечно, могли бы и класс доставщика сделать при помощи интерфейса IDelivering, в котором бы сделали метод доставки, тогда у нас было бы намного больше гибкости и возможности к расширению функционала, но пока что делаем как начали.

[:arrow_up:Содержание](#Содержание)


#### 7. Коллекции данных
Троелсен:
- Глава 9. Коллекции и обобщения с.341

Коллекции. Они используются всюду и везде, потому что нам всегда что-то где-то нужно хранить. Троелсен всё объяснит, скажу только, что инфу о не обобщённых коллекциях как-то сильно особо запоминать не стоит, они сейчас нигде не используются.

#### 7.1 Коллекции как свойства
Может часто возникнуть ситуация, что нам надо как-то сделать так, чтобы любое изменение коллекции происходило только по каким-то правилам. Разберём, на пример, ситуацию, что нам нужно сделать так, чтобы в машину можно было добавлять груз только до тех пор, пока позволяет её грузоподъёмность и пока в ней ещё есть место. На данный момент наши знания позволяют сделать только вот так:
```csharp
//Груз машины.
public List<Product> Cargo {get; private set;}
```
Мы применили стандартные свойства языка C#, и хотя бы обезопасили себя от того, что снаружи класса можно будет затереть наш список вот таким образом:
```csharp
Car TestCar = new Car("Car", 60, 700, 5);
TestCar.Cargo = new List<Product>();
```
Это уже что-то, хотя мы всё ещё можем сделать следующее:
```csharp
TestCar.Cargo.Clear();
```
В итоге наш груз всё же будет очищен. Это плохо. А ещё мы можем вставить или удалить что-то в обход наших правил.
```csharp
TestCar.Cargo.Add(new Product("AK-12"));
```
При таком добавлении мы не делаем проверку на то, есть ли ещё место в машине, мы просто в наглую пихаем туда наш калаш.
Давай разберём, как нам повесить свою логику на все процессы добавления и удаления элементов из коллекций. Для начала вспомним, что каждая обобщённая коллекция, будь то словарь, список, ArrayList и т.д., имеет в своём распоряжении методы добавления и удаления элементов. Было бы круто, если бы мы могли дать снаружи класса только возможность читать элементы коллекции, а так же её свойства, например, количество элементов. Оказывается, что мы можем так сделать. Делается это следующим образом:
```csharp
//Основная коллекция груза
private List<Product> cargo;
//Коллекция для внешнего пользования, которая позволяет только просматривать данные.
public IReadOnlyList<Product> Cargo { get; private set; } 
```
Так-так, тут шот новенькое и незнакомое вылезло - некий IReadOnlyList\<T\> , так вот - это интерфейс, который, который является одним из родителей для класса List\<T\>. Он имеет тот же функционал, что и обычный лист, т.е. так же можно обращаться к элементу по индексу и т.д. Но в нём вырезаны все методы изменения содержимого(точнее, если быть точным, то это в обычном списке все эти методы добавлены, т.к. список является наследником для IReadOnlyList\<T\> и расширяет его функционал). 

Но нам мало просто создать две коллекции, надо связать их вместе, делается это максимально просто.
```csharp
cargo = new List<Product>();
Cargo = cargo;
```
Здесь у нас произойдёт приведение типа List\<Product\> к типу IReadOnlyList\<T\>, это то, что нам надо, этим приведением мы отрезали от списка все методы редактирования. Прекрасно. давай посмотрим, как это всё выглядит на данный момент.

Так выглядит обращение к полю, если бы оно было обычным списком.

![](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Images/List%20methods.jpg)

А так, если это IReadOnlyList\<T\>

![](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/Images/IReadOnlyList%20methods.jpg)

Как видно, во втором случае мы ничего сделать с данными не можем, только посмотреть их.
Так, это всё круто, но нам же ещё надо всё-таки наш груз менять, как это сделать. Очень просто, мы спокойно можем менять внутри класса машины (в нашем случае это машина) содержимое основного списка при помощи его же методов. Вспомним ради чего мы вообще всё это мутим - нам нужно обернуть все изменения товаров в машине в нужную нам логику - "грузим, пока не перегрузили и пока можем запихнуть". Так, вспомнили, теперь давай сделаем, для этого в класс машины добавим метод AddProduct.
```csharp
public void AddProduct(Product product)
{
    /*
     * Здесь все проверки на свободное место и т.д.
     */
    //Вызов метода добавления продукта в основной список.
    cargo.Add(product);
}
```
Сделали, теперь давай проверим, как работает. Напишем быстро в мейне вот такой код для теста:
```csharp
static void Main(string[] args)
{
    Car TestCar = new Car("Car", 60, 700, 5);
    TestCar.AddProduct(new Product("Сайга-9"));
    TestCar.AddProduct(new Product("TR3"));
    foreach (var item in TestCar.Cargo)
       Console.WriteLine(item.Name);
}
```
Вывод: 
```
Сайга-9
TR3
```
Поздравляю, мы успешно загрузили наше оружие, осталось не забыть документы на него и патроны.)))

Для словарей всё абсолютно точно так же, только интерфейсом для них будет IReadOnlyDictionary<TKey,TValue>. Всё остальное точно так же.

[:arrow_up:Содержание](#Содержание)

#### 8. Задание 2.4
Выполняем [Задание 2.4](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F.md#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-24).

[:arrow_up:Содержание](#Содержание)

#### 9. Задание 2.5
Выполняем [Задание 2.5](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F.md#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-25---%D0%B0%D0%B2%D1%82%D0%BE%D0%B8%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-id).

[:arrow_up:Содержание](#Содержание)

#### 10. Задание 2.6
Выполняем [Задание 2.6](https://github.com/ArtemGB/Csharp-Learning-Course/blob/master/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F.md#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-26---%D0%BC%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80-%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D0%BE%D0%B2d).

[:arrow_up:Содержание](#Содержание)

#### 11. Делегаты и события
Троелсен:
- Глава 10. Делегаты, события и лямбда-выражения с.379

Это очень классная и нужная тема. События и лямбда-выражения используются очень часто и много где. В таких технологиях как WPF, Xamarin.Forms, Avalonia и т.д. всё завязано на событиях. Точнее такой паттерн проектирования как MVVM завязан на них. И мы ими также воспользуемся и в нашей программе. Помимо этого полезной вещью являются делегаты. Тоже много где используются. Я, например, использовал их в одном своём проекте - вк боте - для того, чтобы менять поведение в зависимости от входных параметров. И им можно найти ещё кучу других применений.

[:arrow_up:Содержание](#Содержание)

